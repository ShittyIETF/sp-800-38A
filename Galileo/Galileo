#include <cstdarg>
#include <functional>
#include <string>
#include <vector>

// Simple header-only unit testing framework
struct Galileo {
  static void test(const char *testName, std::function<void(void)> testFn) {
    Test t;
    t.name = testName;
    t.fn = testFn;
    allTests().push_back(t);
  }

  static void assert(const char *assertionName, bool assertionValue) {
    if (assertionValue) {
      // Assertion is fine
      return;
    }

    std::printf("Assertion [%s] failed\n", assertionName);
    currentTestFailed() = true;
  }

  static int run(const char *testClassName) {
    printH<'='>("Running tests for class [%s]\n", testClassName);

    for (Test& t: allTests()) {
      printH<'-'>("Running test [%s]\n", t.name.c_str());

      currentTestFailed() = false;
      t.fn();

      printf("[%s] -> %s\n", t.name.c_str(), currentTestFailed() ? "FAIL" : "PASS");
    }

    return 0;
  }

 private:
  // like-printf, fills next line with char patter
  // format is expected to print a line ending with newline
  template <int ch>
  static int printH(const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    int len = vprintf(fmt, args);
    for (int i = 1; i < len; ++i) {
      putchar(ch);
    }
    putchar('\n');
    va_end(args);

    return len * 2;
  }

  struct Test {
    std::string name;
    std::function<void(void)> fn;
  };

  static std::vector<Test>& allTests() {
    static std::vector<Test> allTestsStatic;
    return allTestsStatic;
  }
  static bool& currentTestFailed() {
    static bool b;
    return b;
  }
};

